import { GoogleGenAI, Modality, Chat, GenerateContentResponse } from "@google/genai";
import { ChatMessage } from "../types";

// Helper to initialize the AI client, ensuring the API key is available.
const getAI = () => {
    if (!process.env.API_KEY) {
        // As per guidelines, API_KEY is assumed to be configured. This is a safeguard.
        throw new Error("API_KEY environment variable is not set");
    }
    // Correct initialization as per guidelines
    return new GoogleGenAI({ apiKey: process.env.API_KEY });
};

/**
 * Generates a sticker image from a text prompt using Imagen.
 */
export const generateSticker = async (prompt: string): Promise<string> => {
    const ai = getAI();
    // Using a more descriptive prompt to guide the model for better sticker quality
    const fullPrompt = `A vibrant, high-resolution sticker of ${prompt}, with a clean white border, suitable for printing. The style should be fun and eye-catching, vector art style.`;
    
    const response = await ai.models.generateImages({
        model: 'imagen-4.0-generate-001', // Correct model for high-quality image generation
        prompt: fullPrompt,
        config: {
            numberOfImages: 1,
            outputMimeType: 'image/png', // PNG for transparency support
            aspectRatio: '1:1', // Stickers are often square
        },
    });

    const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
    return `data:image/png;base64,${base64ImageBytes}`;
};

/**
 * Edits an existing sticker image based on a text prompt.
 */
export const editSticker = async (base64ImageData: string, mimeType: string, prompt: string): Promise<string> => {
    const ai = getAI();
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image', // Correct model for image editing
        contents: {
            parts: [
                {
                    inlineData: {
                        data: base64ImageData,
                        mimeType: mimeType,
                    },
                },
                {
                    text: prompt,
                },
            ],
        },
        config: {
            // responseModalities is required for image output from this model
            responseModalities: [Modality.IMAGE],
        },
    });

    // Extracting image from the response as per guidelines
    for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
            const base64ImageBytes: string = part.inlineData.data;
            return `data:image/png;base64,${base64ImageBytes}`;
        }
    }
    throw new Error("No image was generated by the edit operation.");
};

/**
 * Provides a deep analysis of an image using a model with a thinking budget.
 */
export const analyzeImageWithThinking = async (base64ImageData: string, mimeType: string): Promise<string> => {
    const ai = getAI();
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-pro', // Using pro model for complex reasoning
        contents: {
            parts: [
                {
                    inlineData: {
                        data: base64ImageData,
                        mimeType: mimeType,
                    },
                },
                {
                    text: 'Provide a deep analysis of this sticker design. Comment on its style, potential audience, color palette, and suggest 3 concrete improvements to make it more visually appealing or marketable.',
                },
            ],
        },
        config: {
            // Using thinking budget for more detailed reasoning
            thinkingConfig: { thinkingBudget: 8192 },
        },
    });
    // Extracting text from response as per guidelines
    return response.text;
};

/**
 * Removes the background from an image, making it transparent.
 */
export const removeBackground = async (base64ImageData: string, mimeType: string): Promise<string> => {
    const ai = getAI();
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image', // Correct model for this image editing task
        contents: {
            parts: [
                {
                    inlineData: {
                        data: base64ImageData,
                        mimeType: mimeType,
                    },
                },
                {
                    text: 'Remove the background of this image completely, leaving only the main subject with a transparent background. Output as a PNG.',
                },
            ],
        },
        config: {
            responseModalities: [Modality.IMAGE],
        },
    });

    for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
            const base64ImageBytes: string = part.inlineData.data;
            return `data:image/png;base64,${base64ImageBytes}`;
        }
    }
    throw new Error("Could not remove background from image.");
};

/**
 * Handles a conversational chat with the support bot.
 */
export const chatWithBot = async (history: ChatMessage[], newMessage: string): Promise<string> => {
    const ai = getAI();

    // In React, the `history` state passed here is from the previous render, so it does not contain `newMessage`.
    // It's the correct history for the chat session.
    
    // Convert app's ChatMessage format to Gemini's Content format for history.
    // We slice(1) to remove the initial hardcoded bot greeting, which isn't part of a conversation turn.
    const geminiHistory = history.slice(1).map(msg => ({
        role: msg.sender === 'user' ? 'user' : 'model',
        parts: [{ text: msg.text }]
    }));

    const chat: Chat = ai.chats.create({
        model: 'gemini-2.5-flash', // Correct model for chat
        history: geminiHistory,
        config: {
            systemInstruction: 'You are PapayaBot, a friendly and helpful customer support agent for the Papaya AI Designer app. You specialize in helping users with their sticker designs. Keep your answers concise and helpful.',
        },
    });

    const response: GenerateContentResponse = await chat.sendMessage({ message: newMessage });
    return response.text;
};
